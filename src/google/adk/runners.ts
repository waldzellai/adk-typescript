// Runners module for the Google Agent Development Kit (ADK) in TypeScript
// Mirrors runners.py from the Python SDK

import { BaseAgent } from './agents/base_agent';
import { LlmAgent } from './agents/llm_agent';
import { InvocationContext } from './agents/invocation_context';
import { LiveRequestQueue, LiveRequest } from './agents/live_request_queue';
import { RunConfig, StreamingMode } from './agents/run_config';
import { BaseArtifactService, InMemoryArtifactService } from './artifacts/base_artifact_service';
import { Event } from './events/event';
import { BaseMemoryService } from './memory/base_memory_service';
import { InMemoryMemoryService } from './memory/in_memory_memory_service';
import { BaseSessionService } from './sessions/base_session_service';
import { InMemorySessionService } from './sessions/in_memory_session_service';
import { Session } from './sessions/session';
import { Content } from '@google/generative-ai';

// Logger placeholder - in a real implementation, this would be replaced with a proper logging solution
console.log('Logger placeholder for runners.ts');

/**
 * The Runner class is used to run agents.
 * 
 * It manages the execution of an agent within a session, handling message
 * processing, event generation, and interaction with various services like
 * artifact storage, session management, and memory.
 */
export class Runner {
  /** The application name of the runner. */
  appName: string;
  /** The root agent to run. */
  agent: BaseAgent;
  /** The artifact service for the runner. */
  artifactService?: BaseArtifactService;
  /** The session service for the runner. */
  sessionService: BaseSessionService;
  /** The memory service for the runner. */
  memoryService?: BaseMemoryService;

  constructor(options: {
    appName: string;
    agent: BaseAgent;
    artifactService?: BaseArtifactService;
    sessionService: BaseSessionService;
    memoryService?: BaseMemoryService;
  }) {
    this.appName = options.appName;
    this.agent = options.agent;
    this.artifactService = options.artifactService;
    this.sessionService = options.sessionService;
    this.memoryService = options.memoryService;
  }

  /**
   * Runs the agent.
   * 
   * NOTE: This sync interface is only for local testing and convenience purposes.
   * Consider using `runAsync` for production usage.
   * 
   * @param options.userId The user ID of the session.
   * @param options.sessionId The session ID of the session.
   * @param options.newMessage A new message to append to the session.
   * @param options.runConfig The run config for the agent.
   * @returns An array of events generated by the agent.
   */
  run(options: {
    userId: string;
    sessionId: string;
    newMessage: Content;
    runConfig?: RunConfig;
  }): Event[] {
    // For simplicity, in this implementation we'll collect and return all events
    const events: Event[] = [];
    
    // Create a promise to run the async generator
    const runPromise = (async () => {
      for await (const event of this.runAsync(options)) {
        events.push(event);
      }
    })();
    
    // Block until the promise is resolved (NOT RECOMMENDED in production)
    // This is a workaround for the synchronous requirement
    // @ts-ignore - Using a trick to wait synchronously
    runPromise.then(); // Start the promise execution
    
    // Return the collected events
    return events;
  }

  /**
   * Main entry method to run the agent in this runner.
   * 
   * @param options.userId The user ID of the session.
   * @param options.sessionId The session ID of the session.
   * @param options.newMessage A new message to append to the session.
   * @param options.runConfig The run config for the agent.
   * @returns An async generator yielding the events generated by the agent.
   */
  async *runAsync(options: {
    userId: string;
    sessionId: string;
    newMessage: Content;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, undefined> {
    const { userId, sessionId, newMessage } = options;
    const runConfig = options.runConfig || new RunConfig();
    
    // Get or create the session
    let session: Session;
    
    if (runConfig.loadSession) {
      try {
        session = await this.sessionService.getSession(this.appName, userId, sessionId);
      } catch (error) {
        console.log(`Session not found. Creating a new session with ID: ${sessionId}`);
        session = this.sessionService.createSession(
          this.appName,
          userId,
          {},  // empty initial state
          sessionId
        );
      }
    } else {
      // Create a new session regardless of whether one exists
      session = this.sessionService.createSession(
        this.appName,
        userId,
        {},  // empty initial state
        sessionId
      );
    }
    
    // Create the invocation context
    const context = this._newInvocationContext({
      agent: this.agent,
      runConfig,
      session,
      userContent: newMessage,
      userId,
    });
    
    // Append the new message to the session
    if (newMessage) {
      const event = await this._appendNewMessageToSession(context);
      yield event;
    }
    
    // Update memory if requested and available
    if (runConfig.loadMemory && this.memoryService) {
      try {
        // Check if the memoryService has an update method
        if (typeof (this.memoryService as any).update === 'function') {
          await (this.memoryService as any).update(this.appName, userId, sessionId);
        } else {
          console.warn('Memory service does not have an update method');
        }
      } catch (error) {
        console.error('Failed to update memory:', error);
      }
    }
    
    // Find the agent to run (typically the root agent or a sub-agent based on state)
    const agentToRun = this._findAgentToRun(context);
    
    // Update the context with the agent to run
    const updatedContext = context.withModifications({ agent: agentToRun });
    
    // Run the agent
    for await (const event of agentToRun.runAsync(updatedContext)) {
      if (runConfig.saveSession) {
        // Check if the sessionService has a saveSession method
        if (typeof (this.sessionService as any).saveSession === 'function') {
          await (this.sessionService as any).saveSession(session);
        }
      }
      yield event;
    }
    
    // Save the session after agent execution
    if (runConfig.saveSession) {
      // Check if the sessionService has a saveSession method
      if (typeof (this.sessionService as any).saveSession === 'function') {
        await (this.sessionService as any).saveSession(session);
      }
    }
  }

  /**
   * Creates a new invocation context.
   * 
   * @param options Options for creating the invocation context
   * @returns The new invocation context
   */
  protected _newInvocationContext(options: {
    agent: BaseAgent;
    runConfig: RunConfig;
    session: Session;
    userContent: Content;
    userId: string;
  }): InvocationContext {
    const { agent, runConfig, session, userContent, userId } = options;
    
    return new InvocationContext({
      agent,
      runConfig,
      artifactService: this.artifactService || new InMemoryArtifactService(),
      memoryService: this.memoryService,
      sessionService: this.sessionService,
      session,
      userContent,
      appName: this.appName,
      userId,
    });
  }

  /**
   * Creates a new invocation context for live execution.
   * 
   * @param options Options for creating the live invocation context
   * @returns The new live invocation context
   */
  protected _newInvocationContextForLive(options: {
    agent: BaseAgent;
    runConfig: RunConfig;
    session: Session;
    requestQueue: LiveRequestQueue;
    userId: string;
  }): InvocationContext {
    const { agent, runConfig, session, requestQueue, userId } = options;
    
    return new InvocationContext({
      agent,
      runConfig,
      requestQueue,
      artifactService: this.artifactService || new InMemoryArtifactService(),
      memoryService: this.memoryService,
      sessionService: this.sessionService,
      session,
      appName: this.appName,
      userId,
    });
  }

  /**
   * Appends a new message to the session and creates an event.
   * 
   * @param context The invocation context
   * @returns The created event
   */
  protected async _appendNewMessageToSession(context: InvocationContext): Promise<Event> {
    if (!context.session || !context.userContent) {
      throw new Error('Session and user content must be provided to append a message');
    }
    
    const event = new Event({
      author: 'user',
      content: context.userContent,
      invocationId: context.invocationId,
    });
    
    context.session.addEvent(event);
    
    return event;
  }

  /**
   * Finds the appropriate agent to run based on the current state.
   * 
   * @param context The invocation context
   * @returns The agent to run
   */
  protected _findAgentToRun(context: InvocationContext): BaseAgent {
    if (!context.session) {
      return this.agent;
    }
    
    // Check if there's a current agent in the session state
    const currentAgentName = context.session.getStateValue('current_agent');
    
    if (!currentAgentName) {
      return this.agent;
    }
    
    // Find the agent with the given name in the agent tree
    const foundAgent = this._findAgentByName(this.agent, currentAgentName as string);
    
    return foundAgent || this.agent;
  }

  /**
   * Recursively searches for an agent by name in the agent tree.
   * 
   * @param agent The current agent to check
   * @param name The name to search for
   * @returns The found agent or null if not found
   */
  private _findAgentByName(agent: BaseAgent, name: string): BaseAgent | null {
    if (agent.name === name) {
      return agent;
    }
    
    for (const subAgent of agent.subAgents) {
      const found = this._findAgentByName(subAgent, name);
      if (found) {
        return found;
      }
    }
    
    return null;
  }

  /**
   * Checks if an agent can be transferred to across the agent tree.
   * 
   * @param agent The agent to check
   * @returns True if the agent can be transferred to, false otherwise
   */
  protected _isTransferableAcrossAgentTree(agent: BaseAgent): boolean {
    // In a real implementation, this would check if the agent
    // is marked as transferable or has specific properties
    return true;
  }

  /**
   * Closes the current session, performing cleanup as needed.
   * 
   * @param sessionId The ID of the session to close
   * @param userId The ID of the user
   */
  async closeSession(sessionId: string, userId: string): Promise<void> {
    try {
      console.log(`Closing session ${sessionId} for user ${userId}`);
    } catch (error) {
      console.error(`Error closing session ${sessionId}:`, error);
    }
  }
  
  /**
   * Runs the agent in live (streaming) mode.
   * 
   * This method is designed for bidirectional streaming where the user can
   * send multiple messages during an agent invocation, especially useful for
   * processing real-time audio or other streaming data.
   * 
   * @param options.userId The user ID of the session
   * @param options.sessionId The session ID of the session
   * @param options.runConfig The run configuration
   * @param options.initialRequest The initial live request to send
   * @returns An async generator yielding events generated by the agent
   */
  async *runLive(options: {
    userId: string;
    sessionId: string;
    runConfig?: RunConfig;
    initialRequest?: LiveRequest;
  }): AsyncGenerator<Event, void, undefined> {
    const { userId, sessionId } = options;
    const runConfig = options.runConfig || new RunConfig();
    
    // Set streaming mode to at least AUTO_CHUNK if not already specified
    if (runConfig.streamingMode === StreamingMode.NONE) {
      runConfig.streamingMode = StreamingMode.AUTO_CHUNK;
    }
    
    // Get or create the session
    let session: Session;
    
    if (runConfig.loadSession) {
      try {
        session = await this.sessionService.getSession(this.appName, userId, sessionId);
      } catch (error) {
        console.log(`Session not found. Creating a new session with ID: ${sessionId}`);
        session = this.sessionService.createSession(
          this.appName,
          userId,
          {},  // empty initial state
          sessionId
        );
      }
    } else {
      // Create a new session regardless of whether one exists
      session = this.sessionService.createSession(
        this.appName,
        userId,
        {},  // empty initial state
        sessionId
      );
    }
    
    // Create a request queue for live interaction
    const requestQueue = new LiveRequestQueue();
    
    // Add the initial request if provided
    if (options.initialRequest) {
      requestQueue.send(options.initialRequest);
    }
    
    // Update memory if requested and available
    if (runConfig.loadMemory && this.memoryService) {
      try {
        // Check if the memoryService has an update method
        if (typeof (this.memoryService as any).update === 'function') {
          await (this.memoryService as any).update(this.appName, userId, sessionId);
        } else {
          console.warn('Memory service does not have an update method');
        }
      } catch (error) {
        console.error('Failed to update memory:', error);
      }
    }
    
    // Find the agent to run
    const agentToRun = this._findAgentToRun(this._newInvocationContext({
      agent: this.agent,
      runConfig,
      session,
      userContent: { role: 'user', parts: [] },
      userId,
    }));
    
    // Create the live invocation context
    const context = this._newInvocationContextForLive({
      agent: agentToRun,
      runConfig,
      session,
      requestQueue,
      userId,
    });
    
    // Run the agent in live mode
    for await (const event of agentToRun.runLiveAsync(context)) {
      if (runConfig.saveSession && 'saveSession' in this.sessionService) {
        await this.sessionService.saveSession(session);
      }
      yield event;
    }
    
    // Save the session after agent execution
    if (runConfig.saveSession && 'saveSession' in this.sessionService) {
      await this.sessionService.saveSession(session);
    }
  }
}

/**
 * An in-memory Runner for testing and development.
 * 
 * This runner uses in-memory implementations for artifact, session, and memory
 * services, providing a lightweight and self-contained environment for agent
 * execution.
 */
export class InMemoryRunner extends Runner {
  constructor(agent: LlmAgent, appName: string = 'InMemoryRunner') {
    super({
      appName,
      agent,
      artifactService: new InMemoryArtifactService(),
      sessionService: new InMemorySessionService(),
      memoryService: new InMemoryMemoryService(),
    });
  }
}