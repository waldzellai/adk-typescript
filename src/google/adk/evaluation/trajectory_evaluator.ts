// Trajectory evaluator module for the Google Agent Development Kit (ADK) in TypeScript
// Mirrors the trajectory evaluator functionality from the Python SDK

import { EvaluationResult } from './evaluation_generator';
import { TOOL_TRAJECTORY_SCORE_KEY } from './evaluation_constants';

/**
 * Results of the trajectory evaluation.
 */
export interface TrajectoryEvaluationResult {
  score: number;
  details: TrajectoryEvaluationDetails[];
}

/**
 * Detailed results for a specific trajectory evaluation.
 */
export interface TrajectoryEvaluationDetails {
  query: string;
  expectedTools: string[];
  actualTools: string[];
  score: number;
  match: boolean;
  reason?: string;
}

/**
 * Responsible for evaluating tool trajectories (sequences of tool calls) used by agents.
 */
export class TrajectoryEvaluator {
  /**
   * Evaluates tool trajectories against expected tool use.
   * 
   * @param evaluationResponse The responses generated by the agent
   * @param criteria Evaluation criteria
   * @param printDetailedResults Whether to print detailed results
   * @returns Trajectory evaluation results
   */
  static evaluate(
    evaluationResponse: EvaluationResult,
    criteria: Record<string, number>,
    printDetailedResults: boolean = false
  ): TrajectoryEvaluationResult {
    const details: TrajectoryEvaluationDetails[] = [];
    let totalScore = 0;
    let evaluatedCount = 0;
    
    for (const response of evaluationResponse.responses) {
      // Skip responses that don't have expected tool use defined
      if (!response.expectedToolUse || !Array.isArray(response.expectedToolUse)) {
        continue;
      }
      
      // Normalize actual tool use
      const actualTools = response.actualToolUse || [];
      const expectedTools = response.expectedToolUse;
      
      // Evaluate the match between expected and actual tools
      const { match, score, reason } = this.evaluateToolMatch(expectedTools, actualTools);
      
      details.push({
        query: response.query,
        expectedTools,
        actualTools,
        score,
        match,
        reason
      });
      
      totalScore += score;
      evaluatedCount++;
    }
    
    // Calculate average score
    const avgScore = evaluatedCount > 0 ? totalScore / evaluatedCount : 0;
    
    // Print detailed results if requested
    if (printDetailedResults) {
      console.log('Detailed results of trajectory evaluation:');
      console.log('----------------------------------------');
      
      for (const detail of details) {
        console.log(`Query: ${detail.query}`);
        console.log(`Expected Tools: ${detail.expectedTools.join(', ')}`);
        console.log(`Actual Tools: ${detail.actualTools.join(', ')}`);
        console.log(`Match: ${detail.match ? 'YES' : 'NO'}`);
        console.log(`Score: ${detail.score.toFixed(3)}`);
        if (detail.reason) {
          console.log(`Reason: ${detail.reason}`);
        }
        console.log('----------------------------------------');
      }
      
      console.log(`Average Trajectory Score: ${avgScore.toFixed(3)}`);
      console.log(`Evaluated Count: ${evaluatedCount}`);
      
      // Check against criteria
      if (TOOL_TRAJECTORY_SCORE_KEY in criteria) {
        const threshold = criteria[TOOL_TRAJECTORY_SCORE_KEY];
        console.log(`Trajectory Score Threshold: ${threshold.toFixed(3)}`);
        console.log(`Trajectory Score Result: ${avgScore >= threshold ? 'PASS' : 'FAIL'}`);
      }
    }
    
    return {
      score: avgScore,
      details
    };
  }
  
  /**
   * Evaluates the match between expected and actual tool use.
   * 
   * @param expectedTools Expected tool sequence
   * @param actualTools Actual tool sequence
   * @returns Evaluation result with match status, score and explanation
   */
  private static evaluateToolMatch(
    expectedTools: string[],
    actualTools: string[]
  ): { match: boolean; score: number; reason?: string } {
    // If no tools were expected and none were used, that's a perfect match
    if (expectedTools.length === 0 && actualTools.length === 0) {
      return { match: true, score: 1.0 };
    }
    
    // If tools were expected but none were used
    if (expectedTools.length > 0 && actualTools.length === 0) {
      return {
        match: false,
        score: 0.0,
        reason: 'Expected tools to be used, but none were called.'
      };
    }
    
    // If no tools were expected but some were used
    if (expectedTools.length === 0 && actualTools.length > 0) {
      return {
        match: false,
        score: 0.0,
        reason: 'No tools were expected to be used, but some were called.'
      };
    }
    
    // Calculate the tool sequence similarity
    const matchCount = this.calculateToolSequenceMatch(expectedTools, actualTools);
    const maxLength = Math.max(expectedTools.length, actualTools.length);
    const score = matchCount / maxLength;
    
    // Exact match
    if (matchCount === maxLength) {
      return { match: true, score: 1.0 };
    }
    
    // Partial match
    let reason = '';
    if (expectedTools.length !== actualTools.length) {
      reason = `Length mismatch: expected ${expectedTools.length} tool calls, but got ${actualTools.length}.`;
    } else {
      // Find the mismatched positions
      const diffPositions = expectedTools
        .map((tool, idx) => actualTools[idx] !== tool ? idx : -1)
        .filter(pos => pos !== -1);
      
      if (diffPositions.length > 0) {
        reason = `Tool mismatch at position(s): ${diffPositions.join(', ')}.`;
      }
    }
    
    return {
      match: false,
      score,
      reason
    };
  }
  
  /**
   * Calculates the number of matching tools in sequence.
   * 
   * @param expectedTools Expected tool sequence
   * @param actualTools Actual tool sequence
   * @returns The number of matching tools in sequence
   */
  private static calculateToolSequenceMatch(expectedTools: string[], actualTools: string[]): number {
    // Use the Longest Common Subsequence (LCS) algorithm
    const m = expectedTools.length;
    const n = actualTools.length;
    
    // Create a table to store lengths of LCS for all sub-problems
    const lcs = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
    
    // Fill the LCS table
    for (let i = 0; i <= m; i++) {
      for (let j = 0; j <= n; j++) {
        if (i === 0 || j === 0) {
          lcs[i][j] = 0;
        } else if (expectedTools[i - 1] === actualTools[j - 1]) {
          lcs[i][j] = lcs[i - 1][j - 1] + 1;
        } else {
          lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]);
        }
      }
    }
    
    // LCS[m][n] contains the length of LCS
    return lcs[m][n];
  }
}